MVC Tutorial
============

## Шаг 4 - рефакторинг ##

В этом шаге нет кода, который создаёт новые функции приложения или исправляет ошибки, только код, который изменяет 
архитектуру кода. Такие изменения в коде называются рефакторинг.

### Интерфейсы ###

В предыдущем шаге в контроллере пришлось продублировать код расчёта. Это необходимо было сделать из-за того, что классы
расчётов неззависимы друг от друга - пришлось создавать переменные представлений и моделей в каждом расчёте, объект
представления и модели разных расчётов нельзя присвоить в одну переменную. Для исправления требуется создать базовый 
класс или интерфейс. 

Созданы интерфейсы `IDataModel` для моделей, `ICalculationView` для представлений и `ICalculator` для классов расчёта.
Обратите внимание, что интерфейс `ICalculationView` имеет свойство `Title` - название расчёта, чтобы название было 
связано с конкретным представлением, а не с числовым номером в списке.

Теперь объекты этих классов можно присвоить в переменную, и даже добавить в один список:
```cs
IDataModel model = new SimpleModel(20, 10, Operation.Div);
model = new DoubleModel(42);

List<IDataModel> models = new List<IDataModel>
{
    new SimpleModel(20, 10, Operation.Div),
    new DoubleModel(42)
};
```
Эта возможность теперь используется в классе `CommonView` для выбора нужного представления. В предыдущем шаге в методе
`GetViewIndex()` возвращался номер представления, теперь метод `GetView()` возвращает готовый объект нужного класса. 
Подобные методы реализуют паттерн Метод-Фабрика. 

По хорошему, фабрику лучше сделать в контроллере, а не в представлении (контроллер - управляет, представление - 
показывает). Но тогда придётся оставить метод `GetViewIndex()`, возвращающий номер представления, что тоже не очень 
хорошо - номера представлений не несут смысловой нагрузки, лучше избавиться от лишней сущности в программе. Поэтому, в
этом шаге список представлений находится в контроллере и передаётся в метод `GetView()`, который спрашивает, какой из 
них нужен.

### Выбор калькулятора ###

В предыдущем шаге, помимо ручного создания представления, приходилось вручную создавать калькулятор. Нужен класс, 
выбирающий калькулятор по модели. Этим будет заниматься статический класс `Calculator`. Это не лучшее решение, потому 
что можно представить, что модель `DoubleModel` вполне может быть моделью для других расчётов, но в данном этапе такое
решение работает хорошо. При необходимости, всегда можно сделать рефакторинг.

[← Предыдущий шаг](3-step.md) | [Содержание](index.md) | [Следующий шаг →](5-step.md)
